# Apple-Rush
1. Въведение в тематиката на проекта и използваните технологии.

Темата на нашия проект е 2D игра, в която играчът събира падащи от дървета ябълки. Проектът е направен на програмният език Python. 

Има много подобни игри на нашата, като примери са „Apple Catch“ и „Catch the Apple“, но повечето са много лесни. Нашата се различава точно с това, че е по-трудна.

За направата на проекта е използвана библиотеката Pygame.

Библиотеката pygame е модул с отворен код за езика за програмиране Python, специално предназначен за да помогне за правенето на игри и други мултимедийни приложения. Създаден върху SDL (Simple DirectMedia Layer) библиотека за разработка, pygame може да работи на много платформи и операционни системи.

Избрахме именно Pygame, защото е добър за научаването на разработка на игри и разбирането на повечето елементи в други среди за разработка на игри като Unity и Unreal Engine в дълбочина.


2. Използвани материали

Използваните материали за проекта са артовете, фонта за шрифта на живота и резултата.

Линк за всички анимации на гоблина: https://opengameart.org/content/goblin-free-pixelart
Линк за фона с дърветата: https://i.pinimg.com/originals/a5/eb/9a/a5eb9aeb71480b2289a67ca5298aecc1.jpg

Линк за динамита:
https://www.reddit.com/r/PixelArt/comments/hvmg1g/dynamite/

Линк за фонта: https://github.com/clear-code-projects/UltimatePygameIntro/blob/main/font/Pixeltype.ttf

Линк за ябълката:
https://lh3.googleusercontent.com/vmSisBBmhd44MwZBe1CA1k4iv9KpPOWihTNko1D3GRF39lX-pPTNRrJ7_Uk_MaLo4bX6-tggaTjEzeWy6VCcx2QnnHD1WAGYzqs=s400


3. Описание на функционалности и пречки при изработката

За направата на главните функционалности на играта като ябълките и динамитите е използвана библиотеката random, която ни позволява да направим, така че да се появяват на различни кординати от екрана.


 Ябълките както и динамитите, започват от координат y = 0, и падат с съответна скорост, като за динамитите тя е 7, а за ябълките 3. При колизия с играча или надвишаване на височината на екрана те приемат стойност на y = 0, като обаче благодарение на random функцията стойността на координата x е различна. Съответните предмети падат с поне 300 пиксела разлика(хоризонтално) от последните си координати.


Всичките предмети са изведени във функция, която спрямо това какъв string и подадеш, това извършва. Например:


След „Score“ от 10 започват да се появяват по 2 ябълки, което прави играта малко по-трудна. Разбира се те имат различни координати и всяка има своя собствена проверка при колизия или надвишаване на височината на екрана. Това е направено с цел да не се получават проблеми, като например героят да вземе едната ябълка, но и двете да сменят координатите си за x и y и съответно да се появят наново.


Вече след „Score“ от 20 ябълки идва същинската част от нашата игра. Започват да падат динамити, които са сравнително по-бързи от ябълките. Така трудността става на прилично ниво. Те нямат почти никаква разлика с алгоритъма на ябълките, като просто при колизия с играча се отнема 1 точка от живота му.


Имаме колизии с края на мапа, които ограничават героя да не преминава диапазона, в който падат ябълките и динамитите. В противен случай, играта щеше да е елементарна.


В определени периоди от нашата игра, бързината на героя се увеличава с малко, защото иначе някои ябълки ще бъдат недостижими. Това беше много лесно за направа, тъй като той си имаше своя собствена бързина, която ние увеличавахме при надвишаване на определен „Score”.

Героят има 3 точки на живот, като след всяко пропускане на ябълка се отнема по една. При загуба на 3-те точки или колизия с динамит играта приключва.  И сцената се сменя, като на екрана се появява черен екран с надпис „Game over! Press space to restart!”.


При натискането на Space бутона, животът пак става 3, резултатът се нулира, играчът застава пак на първоначалната си позиция, заедно с ябълките и динамита. По този начин играта се рестартира.


Главните трудности, през които минахме за направата на играта, бяха да направим предметите да падат, не защото представлява голяма трудност, а защото ние нямахме много опит в правенето на игри с Pygame. 

Надписите “Score” и “Life” се създават динамично


За визуализация на екрана използваме screen.blit()


Анимациите от друга страна бяха напълно ново нещо за нас и също ни затрудниха. Успяхме да ги имплементираме чрез списъци (lists) със снимки на движения на ляво и на дясно. С тези списъци се обхождат снимките като на всеки кадър индексът се увеличава с 0.15, за да се обхожда по-бавно.


Индексът се използва като integer, и така на всеки 10 кадъра снимката се променя, чрез което се постига по-бавна и по-реалистична анимация.

Преди display update-а и clock tick-а има този блок код:

Неговата цел е когато не се натиска никой бутон играчът да е в т.нар “idle” положение и снимката му да е Goblin_idle.gif. В този случай отваряме gif-а като image и така се взима първият му кадър.

Наложи се да направим някои рисунки от анимациите “transparent”, защото в противен случай се виждаше черен фон зад героя.

Освен това, понеже при Pygame, не можеш да заредиш gif и с него да направиш анимация, се налагаше gif-а да се раздели на снимки, след което да се правят “transparent”. Това отне доста време, защото при използването на сайтове като remove.bg фона на снимката не се махаше напълно и трябваше отново да се обработват вече от нас на ръка чрез paint.net.

